{"ast":null,"code":"import { HttpResponse } from '@angular/common/http';\nimport { catchError, switchMap, tap, throwError } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/toast.service\";\nimport * as i2 from \"../services/auth.service\";\nimport * as i3 from \"../services/login.service\";\nimport * as i4 from \"@angular/router\";\nfunction extractMsg(body, fallback) {\n  try {\n    if (!body) return fallback;\n    if (typeof body === 'string') {\n      // às vezes backend devolve text/plain\n      return body;\n    }\n    return body.mensagem || body.message || fallback;\n  } catch {\n    return fallback;\n  }\n}\nexport class StatusInterceptor {\n  constructor(toast, auth, login, router) {\n    this.toast = toast;\n    this.auth = auth;\n    this.login = login;\n    this.router = router;\n    this.isRefreshing = false;\n  }\n  intercept(req, next) {\n    // sempre withCredentials para enviar cookies HttpOnly\n    const cloned = req.clone({\n      withCredentials: true\n    });\n    return next.handle(cloned).pipe(\n    // SUCESSO: mostra toast se vier mensagem no body\n    tap(evt => {\n      if (evt instanceof HttpResponse) {\n        const body = evt.body;\n        // só mostra toast se houver mensagem explícita do backend\n        const msg = extractMsg(body, '');\n        if (evt.status >= 200 && evt.status < 300 && msg) {\n          this.toast.success(msg);\n        }\n      }\n    }),\n    // ERRO: trata por status e garante toast\n    catchError(err => {\n      // status 0 = erro de rede/CORS\n      if (err.status === 0) {\n        this.toast.error('Falha de conexão. Verifique sua rede.');\n        return throwError(() => err);\n      }\n      // tenta extrair mensagem do backend (mesmo se text/plain)\n      const msg = extractMsg(err.error, `Erro ${err.status}`);\n      if (err.status === 401) {\n        // somente tenta refresh se configurado e não estiver em refresh\n        if (!this.isRefreshing && environment.refreshPath) {\n          this.isRefreshing = true;\n          return this.login.Refresh().pipe(switchMap(() => {\n            this.isRefreshing = false;\n            // reexecuta a requisição original\n            return next.handle(cloned);\n          }), catchError(inner => {\n            this.isRefreshing = false;\n            this.toast.info('Sessão expirada. Faça login novamente.');\n            this.auth.logoutLocal();\n            this.router.navigate(['/login']);\n            return throwError(() => inner);\n          }));\n        } else {\n          this.toast.info('Não autorizado. Faça login.');\n          this.auth.logoutLocal();\n          this.router.navigate(['/login']);\n        }\n      } else if (err.status === 412) {\n        // PRECONDITION FAILED -> warning\n        this.toast.warn(msg || 'Pré-condição não atendida.');\n      } else if (err.status >= 400 && err.status < 500) {\n        this.toast.error(msg);\n      } else if (err.status >= 500) {\n        this.toast.error(msg || 'Erro interno do servidor.');\n      }\n      return throwError(() => err);\n    }));\n  }\n  static {\n    this.ɵfac = function StatusInterceptor_Factory(t) {\n      return new (t || StatusInterceptor)(i0.ɵɵinject(i1.ToastService), i0.ɵɵinject(i2.AuthService), i0.ɵɵinject(i3.LoginService), i0.ɵɵinject(i4.Router));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: StatusInterceptor,\n      factory: StatusInterceptor.ɵfac\n    });\n  }\n}","map":{"version":3,"names":["HttpResponse","catchError","switchMap","tap","throwError","environment","extractMsg","body","fallback","mensagem","message","StatusInterceptor","constructor","toast","auth","login","router","isRefreshing","intercept","req","next","cloned","clone","withCredentials","handle","pipe","evt","msg","status","success","err","error","refreshPath","Refresh","inner","info","logoutLocal","navigate","warn","i0","ɵɵinject","i1","ToastService","i2","AuthService","i3","LoginService","i4","Router","factory","ɵfac"],"sources":["G:\\Estudos\\Angular\\Orcamentador\\src\\app\\interceptors\\status.interceptor.ts"],"sourcesContent":["import { HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest, HttpResponse } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, catchError, switchMap, tap, throwError } from 'rxjs';\r\nimport { ToastService } from '../services/toast.service';\r\nimport { LoginService } from '../services/login.service';\r\nimport { Router } from '@angular/router';\r\nimport { environment } from '../../environments/environment';\r\nimport { AuthService } from '../services/auth.service';\r\n\r\nfunction extractMsg(body: any, fallback: string) {\r\n  try {\r\n    if (!body) return fallback;\r\n    if (typeof body === 'string') {\r\n      // às vezes backend devolve text/plain\r\n      return body;\r\n    }\r\n    return body.mensagem || body.message || fallback;\r\n  } catch {\r\n    return fallback;\r\n  }\r\n}\r\n\r\n@Injectable()\r\nexport class StatusInterceptor implements HttpInterceptor {\r\n  private isRefreshing = false;\r\n\r\n  constructor(\r\n      private toast: ToastService,\r\n      private auth: AuthService,\r\n      private login: LoginService,\r\n      private router: Router\r\n  ) {}\r\n\r\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n    // sempre withCredentials para enviar cookies HttpOnly\r\n    const cloned = req.clone({ withCredentials: true });\r\n\r\n    return next.handle(cloned).pipe(\r\n        // SUCESSO: mostra toast se vier mensagem no body\r\n        tap(evt => {\r\n          if (evt instanceof HttpResponse) {\r\n            const body: any = evt.body;\r\n            // só mostra toast se houver mensagem explícita do backend\r\n            const msg = extractMsg(body, '');\r\n            if (evt.status >= 200 && evt.status < 300 && msg) {\r\n              this.toast.success(msg);\r\n            }\r\n          }\r\n        }),\r\n\r\n        // ERRO: trata por status e garante toast\r\n        catchError((err: HttpErrorResponse) => {\r\n          // status 0 = erro de rede/CORS\r\n          if (err.status === 0) {\r\n            this.toast.error('Falha de conexão. Verifique sua rede.');\r\n            return throwError(() => err);\r\n          }\r\n\r\n          // tenta extrair mensagem do backend (mesmo se text/plain)\r\n          const msg = extractMsg(err.error, `Erro ${err.status}`);\r\n\r\n          if (err.status === 401) {\r\n            // somente tenta refresh se configurado e não estiver em refresh\r\n            if (!this.isRefreshing && environment.refreshPath) {\r\n              this.isRefreshing = true;\r\n              return this.login.Refresh().pipe(\r\n                  switchMap(() => {\r\n                    this.isRefreshing = false;\r\n                    // reexecuta a requisição original\r\n                    return next.handle(cloned);\r\n                  }),\r\n                  catchError(inner => {\r\n                    this.isRefreshing = false;\r\n                    this.toast.info('Sessão expirada. Faça login novamente.');\r\n                    this.auth.logoutLocal();\r\n                    this.router.navigate(['/login']);\r\n                    return throwError(() => inner);\r\n                  })\r\n              );\r\n            } else {\r\n              this.toast.info('Não autorizado. Faça login.');\r\n              this.auth.logoutLocal();\r\n              this.router.navigate(['/login']);\r\n            }\r\n          } else if (err.status === 412) {\r\n            // PRECONDITION FAILED -> warning\r\n            this.toast.warn(msg || 'Pré-condição não atendida.');\r\n          } else if (err.status >= 400 && err.status < 500) {\r\n            this.toast.error(msg);\r\n          } else if (err.status >= 500) {\r\n            this.toast.error(msg || 'Erro interno do servidor.');\r\n          }\r\n\r\n          return throwError(() => err);\r\n        })\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}